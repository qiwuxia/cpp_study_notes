# 9. 顺序容器

* 顺序容器中元素的顺序与其加入容器的位置相对应。

* 关联容器中元素的位置有元素相关联的关键字值决定。在11章中介绍关联容器特有的操作
* 所有容器类都共享公共的接口，不同容器按不同的方式对其进行扩展。这个公共接口使容器的学习更加容易——我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。
* 一个容器就是一些特定类型对象的集合。**顺序容器**（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，在11章介绍的有序和无序关联容器，则根据关键字的值来存储元素。
* 标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。本章结尾介绍适配器

***

## 9.1 顺序容器概述

下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。只是在一下方面有不同性能折中：

* 向容器添加或从容器中删除元素的代价
* 非顺序访问容器中元素的代价

| vector         | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| -------------- | ------------------------------------------------------------ |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表。只支持单项顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| string         | 与`vector`相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

* 除固定大小的`array`外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作
* 例如：`string` and `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器插入或删除元素速度会很慢，因为要保证其中元素的连续存储，所以将插入或删除的元素后边的所有的元素都移动位置。**另外**，添加一个元素有时还需要分配额外的存儲空间。在这种情况下，每个元素都必须移动到新的存储空间中。
* `list`和`forward_list`两个容器的设计目的是令容器的任何位置插入和删除元素都很迅速。作为代价，这两个容器都不支持随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外存储开销也很大。
* `deque`是一个更为复杂的数据结构。与`string`和`vector`类似，`deque`支持快速的随机访问。`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两端添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。
* `forward_list`和`array`是新C++标准增加的类型。与内置数组相比，`array`是一种更安全、更容易使用的数组类型。与内置数组类似，`array`对象的大小时固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。`forward_list`的设计目标时达到与最好的手写的单项链表数据结构相当的性能，因此，`forword_list`没有`size`操作，因此保存或计算其大小就会比手写链表多出额外的开销。对其他容器来说，`size`保证是一个快速的常量时间的操作。

* 新标准的容器壁旧版本的快的多。新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

***

**确定使用哪种顺序容器**

* 通常，使用`vector`是最好的选择，除非你有更好的理由选择其他容器

以下是一些选择容器的基本原则：

* 除非有更好的理由选择其他容器，否则应使用`vector`

* 如果程序中有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。

* 如果程序要求随机访问元素，应使用`vector`或`deque`。

* 如果程序要求在容器中间插入或删除元素，应使用`list`或`forword_list`

* 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`

* r如果程序只有在输入时才需要在容器中间文职插入元素，随后需要随机访问元素，则

  ——首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数开重拍容器中的元素，从而避免在中间位置添加元素。

  ——如果必须再中间位置插入元素，开路在输入阶段使用`list`,一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

  如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那就取决于再`list`或`forward_list`中范围跟元素与`vector`或`deque`中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入/删除操作更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了

* 如果不确定应该使用哪种容器，可以再程序设计时先只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，再必要时选择使用`vector`或`list`都很方便。

***

## 9.2 容器库概览

容器类型上的操作形成了一种层次：

* 某些操作是所有容器类型提供的
* 有些操作仅针对顺序容器、关联容器或无序容器
* 还有些操作只适用于一小部分容器

***

**公共容器操作**：

| 类型别名       |                                          |
| -------------- | ---------------------------------------- |
| iterator       | 此容器类型的迭代器类型                   |
| const_iterator | 可以读取元素，但不能修改元素的迭代器类型 |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |
|                |                                          |

