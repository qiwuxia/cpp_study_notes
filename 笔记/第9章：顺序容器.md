# 9. 顺序容器

* 顺序容器中元素的顺序与其加入容器的位置相对应。

* 关联容器中元素的位置有元素相关联的关键字值决定。在11章中介绍关联容器特有的操作
* 所有容器类都共享公共的接口，不同容器按不同的方式对其进行扩展。这个公共接口使容器的学习更加容易——我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。
* 一个容器就是一些特定类型对象的集合。**顺序容器**（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，在11章介绍的有序和无序关联容器，则根据关键字的值来存储元素。
* 标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。本章结尾介绍适配器

***

## 9.1 顺序容器概述

下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。只是在一下方面有不同性能折中：

* 向容器添加或从容器中删除元素的代价
* 非顺序访问容器中元素的代价

| vector         | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| -------------- | ------------------------------------------------------------ |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表。只支持单项顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| string         | 与`vector`相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

* 除固定大小的`array`外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作
* 例如：`string` and `vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器插入或删除元素速度会很慢，因为要保证其中元素的连续存储，所以将插入或删除的元素后边的所有的元素都移动位置。**另外**，添加一个元素有时还需要分配额外的存儲空间。在这种情况下，每个元素都必须移动到新的存储空间中。
* `list`和`forward_list`两个容器的设计目的是令容器的任何位置插入和删除元素都很迅速。作为代价，这两个容器都不支持随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与`vector`、`deque`和`array`相比，这两个容器的额外存储开销也很大。
* `deque`是一个更为复杂的数据结构。与`string`和`vector`类似，`deque`支持快速的随机访问。`deque`支持快速的随机访问。与`string`和`vector`一样，在`deque`的中间位置添加或删除元素的代价（可能）很高。但是，在`deque`的两端添加或删除元素都是很快的，与`list`或`forward_list`添加删除元素的速度相当。
* `forward_list`和`array`是新C++标准增加的类型。与内置数组相比，`array`是一种更安全、更容易使用的数组类型。与内置数组类似，`array`对象的大小时固定的，因此，`array`不支持添加和删除元素以及改变容器大小的操作。`forward_list`的设计目标时达到与最好的手写的单项链表数据结构相当的性能，因此，`forword_list`没有`size`操作，因此保存或计算其大小就会比手写链表多出额外的开销。对其他容器来说，`size`保证是一个快速的常量时间的操作。

* 新标准的容器壁旧版本的快的多。新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

***

**确定使用哪种顺序容器**

* 通常，使用`vector`是最好的选择，除非你有更好的理由选择其他容器

以下是一些选择容器的基本原则：

* 除非有更好的理由选择其他容器，否则应使用`vector`

* 如果程序中有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。

* 如果程序要求随机访问元素，应使用`vector`或`deque`。

* 如果程序要求在容器中间插入或删除元素，应使用`list`或`forword_list`

* 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`

* r如果程序只有在输入时才需要在容器中间文职插入元素，随后需要随机访问元素，则

  ——首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数开重拍容器中的元素，从而避免在中间位置添加元素。

  ——如果必须再中间位置插入元素，开路在输入阶段使用`list`,一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

  如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那就取决于再`list`或`forward_list`中范围跟元素与`vector`或`deque`中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入/删除操作更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了

* 如果不确定应该使用哪种容器，可以再程序设计时先只使用`vector`和`list`公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，再必要时选择使用`vector`或`list`都很方便。

***

## 9.2 容器库概览

容器类型上的操作形成了一种层次：

* 某些操作是所有容器类型提供的
* 有些操作仅针对顺序容器、关联容器或无序容器
* 还有些操作只适用于一小部分容器

***

**公共容器操作**：

| 类型别名                                |                                                        |
| --------------------------------------- | ------------------------------------------------------ |
| `iterator`                              | 此容器类型的迭代器类型                                 |
| `const_iterator`                        | 可以读取元素，但不能修改元素的迭代器类型               |
| `size_type`                             | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `differnce_type`                        | 带符号整数类型，足够保存两个迭代器之间的距离元素类型   |
| `value_type`                            | 元素类型                                               |
| `reference`                             | 元素的左值类型：与`value_tyoe&`含义相同                |
| `const_reference`                       | 元素的`const`左值类型（即，`const value_type)          |
| 构造函数                                |                                                        |
| `C c`                                   | 默认构造函数，构造空容器                               |
| `C c1(c2)`                              | 构造`C2`的拷贝`C1`                                     |
| `C c(b, e)`                             | 构造`c`，将迭代器`b`和`e`指定的范围内的元素拷贝到`c`   |
| `C c(a,b,c...)`                         | 列表初始化c                                            |
| 赋值与`swap`                            |                                                        |
| `c1 = c2`                               | 将`c1`中的元素替换为`c2`中的元素                       |
| `c1 = (a, b, c...)`                     | 将`c1`中的元素替换为列表中的元素（不适用`array`）      |
| `a.swap(b)`                             | 交换`a`和`b`的元素                                     |
| `swap(1,b)`                             | 与`a.swap(b)`等价                                      |
| 大小                                    |                                                        |
| `c.size()`                              | `c`中元素的数目（不支持`forward_list`）                |
| `c.max_size()`                          | `c`可保存的最大元素数目                                |
| `c.empty()`                             | 若`c`中存储了元素，返回`false`，否则返回`true`         |
| 添加/删除元素（不适用与`array`)         |                                                        |
| 注：在不同容器中，这些操作的接口都不同  |                                                        |
| `c.insert(args)`                        | 将`args`中的元素                                       |
| `c.emplace(inits)`                      | 使用`inits`构造`c`中的一个元素                         |
| `c.erase(args)`                         | 删除`args`指定的元素                                   |
| `c.clear()`                             | 删除`c`中的所有元素，返回`void`                        |
| `==`,`!=`                               | 所有容器都支持相等（不等运算符）                       |
| `<`,`<=`,`>`,`>=`                       | 关系运算符（无序关联容器不支持）                       |
| 获取迭代器                              |                                                        |
| `c.begin()`,`c.end()`                   | 返回指向`c`的首元素位置（尾元素之后位置）的迭代器      |
| `c.cbegin()`,`c.cend()`                 | 返回`const_iterator`                                   |
| 反向容器的额外成员（不支持forward_list) |                                                        |
| `reverse_iterator`                      | 按逆序寻址元素的迭代器                                 |
| `const_reverse_iterator`                | 不能修改元素的逆序迭代器                               |
| `c.rbegin()`,`c.rend()`                 | 返回指向`c`的尾元素和首元素之前位置的迭代器            |
| `c.crbegin()`,`c.cread()`               | 返回`const_reverse_iterator`                           |

### 9.2.1 迭代器

### 9.2.4 容器的定义和初始化

* 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器累心和元素类型都必须相同；不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型时相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将拷贝的元素转换为要初始化的容器的原类型即可

* 容器赋值运算

  * | `c1 = c2`                             | 将`c1`中的元素替换为`c2`中元素的拷贝。`c1`和`c2`必须具有相同的类型 |
    | ------------------------------------- | ------------------------------------------------------------ |
    | `c = {a, b, c...}`                    | 将`c1`中元素替换为初始化列表中元素的拷贝（array不适用）      |
    | `swap(c1, c2)`                        | 交换`c1`和`c2`中的元素。`c1`和`c2`必须具有相同的类型。`swap`通常比从c2向c1拷贝元素快得多 |
    | `assign`操作不适用与关联容器和`array` |                                                              |
    | `seq.assign(b, e)`                    | 将`seq`中的元素替换为迭代器`b`和`e`所表示的范围中的元素。迭代器`b`和`e`不能指向`seq`中的元素 |
    | `seq.assign(il)`                      | 将`seq`中的元素替换为初始化列表`il`中的元素                  |
    | `seq.assign(n, t)`                    | 将`seq`中的元素替换为`n`个值为t的元素                        |

* 使用`assign`(仅顺序容器)

  * 赋值运算符要求左边和右边的运算对象具有相同的类型。他将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（`array`除外）还定义了一个名为`assign`的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。`assign`操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如我们可以用`assgin`实现将一个`vector`中的一段`char *`值赋予一个`list`中的`string`:

    * ```cpp
      list<string> names;
      vector<const char*> oldstyle;
      names = oldstyle; // 错误：容器类型不匹配
      names.assign(oldstyle.cbegin(), oldstyle.cend()); // 正确。可以将`const char*`转换为`string`
      ```

    * 由于就元素被替换，因此传递给`assign`的迭代器不能指向调用`assign`的容器

  * `assign`的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：

    * ```cpp
      // 等价于slist.clear();后跟slist1.insert(slist1.begin(), 10, "Hiya!");
      list<string> slist1(1);			// 一个元素，为空`string`
      slist1.assign(10, "Hiya!");		// 10个元素，每个都是“Hiya!”
      ```

* 使用 `swap`

  * `swap`操作交换两个相同类型容器的内容。调用`swap`之后，两个容器中的元素将会交换：

    * ```cpp
      vector<string> svec1(10); // 10个元素的vector
      vector<string> svec2(24); // 24个元素的vector
      swap(svec1, svec2); 
      ```

    * 调用`swap`后，`svec1`将包含24个`string`元素，`svec2`将包含10个`string`。除`array`外，交换两个容器内容的操作保证会很快——元素本身并未交换，`swap`只是交换了两个容器的内部数据结构

    * 除了`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。
    
    * 元素不会被移动的事实意味着，除`string`外，指向容器的迭代器、引用和指针在`swap`操作之后都不会失效。它们仍指向`swap`操作之前所指向的那些元素。但是，在`swap`之后，这些元素已经属于不同的容器了。例如，假定`iter`在`swap`之前指向`svec1[3]`的`string`,那么在`swap`之后它指向`svec2[3]`的元素。与其他容器不同，对一个`string`调用`swap`会导致迭代器、引用和指针失效。
    
    * 与其他容器不同，`swap`两个`array`会真正交换他们的元素。因此交换两个array所需的时间与`array`中元素的数目成正比。
    
    * 因此，对于`array`，在`swap`操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个`array`中对应元素的值进行了交换。
    
    * 在新标准中，容器既提供成员函数版本的`swap`，也提供非成员函数版本的`swap`。而早期标准库版本只提供成员函数版本的`swap`。非成员版本的`swap`在泛型编程中是非常重要的。统一使用非成员版本的`swap`是一个好习惯。

### 9.2.6 容器大小操作

除了`forwarl_list`，每个容器类型都有三个大小相关的操作：

* 成员函数`size`，返回容器中元素的数目
* 成员函数`empty`，当`size`为0时返回布尔值`true`，否则返回`false`
* 成员函数`max_size`，返回一个大于或等于该容器所能容纳的最大元素数的值。

`forward_list`支持`max_size`和`empty`，但不支持`size`，原因我们将在下一节解释。

### 9.2.7 关系运算 符

每个容器类型都支持相等运算符（== 和 !=）；除了无序关联容器和双向迭代器（`list`和`forwald_list`）外所有容器都支持关系运算符（>、>=、 <、<=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。即，我们只能将一个`vector<int>`与另一个`vector<int>`进行比较，而不能将一个`vector<int>`与与一个`list<int>`或一个`vector<double>`进行比较。

* 比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与`string`的关系运算类似：
  * 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等
  * 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
  * 如果，两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果
* 容器的关系运算符使用元素的关系运算符完成比较
  * 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器
  * 容器的相等运算符实际上是使用元素的`==`运算符实现比较多，而其他关系运算符是使用元素的`<`运算符。如果元素类型不支持所需i运算符，那么保存这种元素的容器就不能使用相应的关系运算。例如，我们在第7章定义的Sales_data类型并未定义`==`和`<`运算。因此，空就不能比较两个保存`Sales_data`元素的容器：

***

以下为顺序容器特有操作

## 9.3 顺序容器操作（特有）

### 9.3.1 向顺序容器添加操作

除了`array`外，所有标准库容器都提供灵活的內存管理。在运行时可以动态添加或删除元素来改变容器大小。下表为除了`array`外的顺序容器添加元素的操作：

| 这些操作会改变容器的大小;`array`不支持这些操作               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `forward_list`有自己专有版本的`insert`和`emplace`(在9.3.4节) |                                                              |
| `forward_list`不支持`push_back`和`emplace_back`              |                                                              |
| `vector`和`string`不支持`push_front`和`emplace_front`        |                                                              |
| `c.push_back(t)` 和  `c.emplace_back(args)`                  | 在`c`的尾部创建一个值为`t`或由`args`创建的元素。返回`void`   |
| `c.push_front(t)` 和 `c.emplace_front(args)`                 | 在 `c`的头部创建一个值为`t`或由`args`创建的元素。返回`void`  |
| `c.insert(p , t)` 和 `c.emplace(p, args)`                    | 在迭代器`p`指向的元素之前创建一个值为`t`或由`args`创建的元素。返回指向新添加的元素的迭代器 |
| `c.insert(p, n, t)`                                          | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素。返回指向新添加的第一个元素的迭代器；若`n`为0，则返回`p` |
| `c.insert(p, b, e)`                                          | 将迭代器`b`和`e`：`[b, e)`指定的范围内的元素添加到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回`p` |
| `c.insert(p, il)`                                            | `il`是一个花括号包围的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回`p` |

* `string`中的`insert`函数的第一个参数使用`size_t`类型的数来表示位置，而不是使用迭代器表示

* 向一个`vector`、`string`或`deque`插入添加元素会使所有指向容器的迭代器、引用和指针失效

* 除了`array`和`forwarld_list`之外，每个顺序容器（包括`string`类型）都支持`push_back`

* 将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的/然而，这样做可能很耗时

* 使用`insert`的返回值，可以在容器的特定位置反复插入元素：

  * ```cpp
    list<string> lst;
    auto iter = lst.begin();
    while (cin >> word)
        iter = lst.insert(iter, word);  // 等价调用push_front,因为insert的返回值为新插入的word中第一个元素的位置
    
    ```

* 使用`emplace`操作

  * C++11标准引入了三个新成员——`emplace_front、emplace和emplace_back`，这些操作构造而不是拷贝元素。其分别对应`push_front, insert, push_back`，允许我们将元素防止在容器头部、一个指定位置之前或容器尾部。

  * 当调用`push和insert`成员函数是，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而我们调用一个`emplace`成员函数时，则是将参数传递给元素类型的构造函数。`emplace`成员使用这些参数在容器管理的內存空间中直接构造元素。例如，假定`c`保存`Sales_data`元素：

    * ```cpp
      // 在c的末尾构造一个Sales_data对象
      // 使用三个参数的Sales_data构造函数
      c.emplace_back("978-059035403", 245, 15.99); // 正确
      //错误：没有接受三个参数的push_back版本
      c.push_back("978-059035403", 245, 15.99);
      //正确：创建一个临时的Sales_data对象传递给push_back
      c.push_back(Sales_data("978-059035403", 245, 15.99));
      ```

    * 其中对`emplace_back`的调用和第二个`push_back`调用都会创建新的`Sales_data`对象。在调用`emplace_back`时，会在容器管理的内存空间中直接创建对象。而调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

  * `emplace`函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配：

    * ```cpp
      // iter指向c中一个元素，其中保存了Said；es_data元素
      c.emplace_back();   // 使用Sales_data的默认构造函数
      c.emplace(iter, "000-000000000"); // 使用Sales_data(string)
      // 使用Sales_data的接受一个ISBN、一个count和一个price的构造函数
      c.emplace_front("978-0590353403", 25, 15.99);
      ```

    * emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配

### 9.3.2 访问元素

* 包括`array`在内的每个顺序容器都有一个`front`成员函数，而除`forward_list`之外的所有顺序容器都有一个`back`成员函数。这两个操作分别返回首元素和尾元素的引用：

  * ```cpp
    // 在解引用一个迭代器或调用front 或back之前检查是否铀元素
    if (!c.empty())
    {
        // val 和 val2是c中第一个元素值的拷贝
        auto val = *c.begin(), val2 = c.fromt();
        // val3和val4是c中最后一个元素值的拷贝
        auto last = c.end();
        auto val3 = *(--last); // 不能递减forward_list迭代器
        auto val4 = c.back(); // forward_list不支持
    }
    ```

  * 迭代器`end`指向的是容器尾元素之后的（不存在的）的元素。为了获取尾元素，必须首先递减此迭代器。

  * 在调用`front`和`back`（或解引用`begin`和`end`返回的迭代器）之前，要确保`c`非空。如果容器为空，`if`中操作的行为将是未定义的。

* | 在顺序容器中访问元素的操作                           |                                                              |
  | ---------------------------------------------------- | ------------------------------------------------------------ |
  | `at`和下标操作只适用于`string, vector, deque, array` |                                                              |
  | `back不适用于forward_list`                           |                                                              |
  | `c.back()`                                           | 返回c中尾元素的引用。若c为空，函数行为未定义                 |
  | `c.front()`                                          | 返回`c`中首元素的引用。若`c`为空，函数行为未定义             |
  | `c[n]`                                               | 返回`c`中下标为`n`的元素的引用，`n`是一个无符号整数。若`n >= c.size()`，则函数行为未定义 |
  | `c.at[n]`                                            | 返回下标为`n`的元素的引用。如果下标越界。则抛出一`out_of_range`异常 |

  * 对一个空容器调用`front`和`back`，就像使用一个越界的下标一样，是一座严重的程序设计错误

* 访问成员函数返回的是引用
* 下标操作和安全的随机访问
  * 提供快速随机访问的容器（`string, vector, deque, array`）也都提供下标运算符。
  * 如果希望确保下标是合法的，可以使用`at`成员函数。`at`成员函数类似下标运算符，但如果下标越界，`at`会抛出一个`out_of_reqnge`异常

### 9.3.3 删除元素

（非`array`）容器有许多删除元素的方式，如下表：

| 顺序容器的删除操作                                           |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 这些操作 会改变容器的大小，所以不适用于`array`               |                                                              |
| `forward_list`有特殊版本的`erase`,在9.3.4节                  |                                                              |
| `forwarld_list`不知处`pop_back`;  `vector`和`string`不支持`pop_front` |                                                              |
| `c.pop_back()`                                               | 删除`c`中尾元素。若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()`                                              | 删除`c`中首元素。若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)`                                                 | 删除迭代器`p`随指定的元素，返回一个指向最一个被删除之后元素的迭代器，若`p`指向尾元素，则返回尾后迭代器。若`p`是尾后迭代器，则函数行为未定义 |
| `c.erase(b, r)`                                              | 删除迭代器`b`和`e`所指定范围内:`[b, e)`的元素。返回一个指向最后一个被删除元素之后元素的迭代器，若`e`本身就是尾后迭代器，则函数也返回尾后迭代器 |
| `c.clear()`                                                  | 删除`c`中的所有元素。返回`void`                              |

* 删除`deque`中除首尾之外的任何元素都会使所有迭代器、引用和指针失效。指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效。
* 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的

#### pop_front和pop_back成员函数

### 9.3.4 特殊的`forward_list`（单向链表）操作

由于`forward_list` 是单相链表，只能得到选中节点指向的下一节点，而不能获得指向选中节点的上一节点。

而当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要访问其前去，以便改变前驱的链接。但是`forward_list`是单相链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于这个原因，在一个`forward_list`中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。

由于这些操作与其他容器上的操作的实现方式不同，`forward_list`并未定义`insert, emplace和 erase`，而是定义了名为`insert_after, emplace_after, erase_after`的操作。例如，在我们的例子中，为了删除`elem3`，应该用指向`elem2`的迭代器调用`erase_after`。为了支持这些操作，`forward_list`也定义了`before_begin`，它返回一个 **首前**（off-the-beginning）迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。

| 在`forward_list中插入或删除元素的操作`                       |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `lst.before_begin(), lst.cbefore_begin()`                    | 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。`cbefore_begin()`返回一个const_iterator |
| `lst.insert_after(p,t), lst.insert_after(p, n, t), lst.insert_after(p, b, e), lst.insert_after(p, il)` | 在得带起`p`之后的位置插入元素。`t`是一个对象，`n`是数量，`b`和`e`是表示范围的一堆迭代器（`b`和`e`不能指向`lst`内），`il`是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回`p`。若`p`为尾后迭代器，则函数行为未定义 |
| `emplace_after(p, args)`                                     | 使用`args`在`p`指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义 |
| `lst.erase_after(p), lst.erase-after(b, e)`                  | 删除`p`指向的位置之后的元素， 或删除从b之后直到（但不包含）e之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义 |

### 9.3.5 改变容器大小

| 顺序容器大小操作        |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| `resize`不适用于`array` |                                                              |
| `c.resize(n)`           | 调整c的大小为n个元素。若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n, t)`        | 调整c的大小为n个元素。任何新添加的元素都吃初始化为值`t`      |

* 如果`resize`缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对`vector, string, deque`进行`resize`可能导致迭代器、指针和引用失效。

### 9.3.6 容器操作可能使迭代器失效

* ``std::vector::size`
  * `vec.size()` 返回`vec`中元素的个数

*  `std::vector::capacity`
  * `vec.capacity() `返回`vec`在内存中分配的空间大小

* 向在向容器添加元素后：

  * 如果容器是`vector`或`string`， 且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间内未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效

  * 对于`deque`， 插入到首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效，但如果内存空间重新分配，也会导致迭代器、指针和引用失效。

  * 对于`list`和`forward_list`， 指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效

*  删除元素后，指向被删除元素的迭代器、指针和引用会失效，另外：
  * 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效
  * 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果删除首元素，这些也不会受影响
  * 对于`vector`和`string`，指向被删元素之前的迭代器、引用和指针仍有效。
  * 当我们删除元素时，尾后迭代器总是会失效
  * 使用失效的迭代器、指针或引用时严重的运行时错误
* 当使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好多方法
* 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。这个建议对`vector, string, deque`尤为重要

1. 不要保存`end`返回的迭代器

## 9.4 `vector`对象是如何增长的

* 标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的內存空间是，`vector`和`string`的实现通常会分配比新的空间需求更大的內存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次团价新元素都重新分配容器的內存空间了。
* 这种分配策略比每次添加新元素都重新分配容器内存空间的策略要高效的多。其实际性能也表现得足够好——虽然`vector`在每次重新分配内存空间是都要移动元素，但使用此策略后，其扩张操作通常比`list`和`deque`还要快

***

* 管理容量的成员函数

  * `vector`和`srting`类型提供了一些成员函数，允许我们与它的实现中內存分配部分互动。`capacity`操作告诉我们容器在不扩张內存空间的情况下可以容纳多少个元素。`reserve`操作允许我们通知容器它应该准备保存多少个元素。

  * | 容器大小管理操作                                |                                                              |
    | ----------------------------------------------- | ------------------------------------------------------------ |
    | `shrink_to_fit`只适用于 `vector, string, deque` |                                                              |
    | `capacity`和`reserve`只适用于`vector`和`string` |                                                              |
    | `c.shrink_to_fit()`                             | 请将`capacity()`减少为于`size()`相同大小                     |
    | `c.capacity()`                                  | 不重新分配內存空间的话，`c`可以保存多少元素。函数返回能保存的元素个数 |
    | `c.reserve(n)`                                  | 分配至少能容纳`n`个元素的內存空间                            |

    * `reserve`并不改变容器中元素的数量，它仅影响`vector`预先分配多大的內存空间

  * 只有当需要的內存空间超过当前容量时，`reserve`调用才会改变`vector`的容量。如果需求大小大于当前容量，`reserve`至少分配与需求一样大的内存空间（可能更大）

  * 如果需求大小小于或等于当前容量，`reserve`什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用`reserve`之后，`capacity`将会大于或等于传递给`reserve`的参数

  * 调用`reserve`永远不会减少容器占用的內存空间。类似的，`resize`成员函数只改变容器中元素的数目，而不是容器的容量

  * 新标准库中，我们可以调用`shrink_to_fit`来要求`deque, vector, string`退回不需要的内存空间。此函数指出我们不再需要任何多余的內存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用`shrink_to_fit`也不一定保证一定退回內存空间。

***

* `capacity`和`size`

  * 容器的`size`是指它已经保存的元素的数目；而`capacity`则是在不分配新的內存空间的前提下它最多可以保存多少元素。
  * 只有在执行`insert`操作时`size`与`capacity`相等，或者调用`resize`或`reserve`时给定的大小超过当前`capacity`,`vector`才可能重新分配内存空间。会分配多少超过给定容量的额外空间，取决于具体实现。
  * 所有实现都应遵循一个原则：确保用`push_back`向`vector`添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的`vector`上调用`n`次`push_back`来创建一个`n`个元素的`vector`,所花费的时间不能超过`n`的常数倍

  

