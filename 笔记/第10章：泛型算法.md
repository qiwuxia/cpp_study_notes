# 第十章：泛型算法

标准库提供了一组算法，这些算法的大多数都独立于任何特定的容器。这些算法是通用的（generic,或称泛型的）：它们可用于不同类型的容器和不同类型的元素

## 10.1 概述

大多数算法都定义在头文件`algorithm`中。标准库还在头文件`numeric`中定义了一组数值泛型算法.

***

* `find`算法: `find(pos1, pos2, val)`在[pos1, pos2)迭代器范围内寻找`val`，并返回指向第一个`val`的值,未找到将返回`pos2`

***

* 关键概念：算法永远不会执行容器的操作

  * 泛型算法本身不会执行容器的操作。他们只会运行在迭代器之上，执行迭代器的操作。
  * 泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程设定：
    * 算法永远不会改变底层容器的大小
    * 算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素
    * 标准库定义了一类特殊的迭代器，成为插入器（`insrter`)。当给这类 迭代器赋值时，他们会在底层的容器上执行插入操作。因此当一个算法操作这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作

  

  

  ***

  ## 10.2 初始泛型算法

  理解算法的最基本的方法就是了解他们是否读取元素、改变元素或是重排元素顺序

  ### 10.2.1 只读算符

  * `accumulate()`求和函数：
    * 定义在`numeric`头文件中， 接收三个参数，前两个指出需要求个的元素的范围，第三个参数是和的初值：
      * `int sum = accumulate(vec.cbegin(), vec.end(), 0)`
    * 第三个参数的类型决定了函数使用那个假发运算符以及返回值的类型
  * `equal()`算法：用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回`true`，否则返回`false`。此算法接受三个迭代器：前两个(与以往一样)表示第一个序列中的元素范围，第三个表示第二个序列的首元素：
    * `equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());`
    * 由于`euqal`利用迭代器完成操作，因此我们通过调用`equal`来比较两个不同类型的容器的元素。而且，元素类型也不必一样，只要我们能用`==`来比较两个元素类型即可。
    * `equal`基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。
  * `find()`查找算法：在两个迭代器指定的范围内查找一个值：
    * `auto =  find(vec.cbegin(), vec.cend(), val)`;返回指向第一个等于给定值的元素的迭代器
  * `count`函数，类似`find`，返回给定值在序列中出现的次数。
  
  
  
  ### 10.2.2 写容器元素的算法
  
  一些算法将新值赋予序列中的元素。当使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。算法不会执行容器操作，因此他们自身不可能改变容器的大小。
  
  
  
  * `fill`算法：
    * 接受一对迭代器表示一个范文，还接受一个值作为第三个参数。`fill`将给定的值赋予输入序列中的每个元素
    * `fill(vec.begin(), vec.end(), 0)` //将每个元素充值为0
  
  
  
  ***
  
  1. 概念：算法不检查写操作
  
  * `fill_n`算法函数：
    * 接受一个但迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。
  
  ***
  
  #### 介绍`bacl_inserter`
  
  一种保证算法有足够元素空间来容纳输出数据的方法是使用`插入迭代器`(insert iterator)。现在为了展示如何用算法向容器写入数据，我们现在将使用`back_inserter`，它是定义在头文件`iterator`中的一个函数。
  
  * `back_inserter`算法函数：
  
    * 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中：
  
      * ```cpp
        vector<int> vec; // 空向量
        auto it = back_inserter(vec); // 通过它赋值会将元素添加到vec中
        *it = 42; // vec中现在有一个元素，值为42
        ```
  
    * 我们常常使用`back_inserter`创建一个迭代器，作文算法的目的位置来使用。例如：
  
      * ```cpp
        vector<int> vec; // 空向量
        // 正确：back_inserter创建一个插入迭代器，可以来向vec添加元素
        fill_n(back_inserter(vec), 10, 0); // 添加10个元素到vec
        ```
  
      * 在每步迭代中，`fill_n`向给定序列的一个元素赋值。由于我们传递的参数时`back_inserter`返回的迭代器，因此每次赋值都会在`vec`上调用`push_back`
  
  #### 拷贝算法
  
  * `copy`算法函数：
    * 接受三个迭代器参数，前两个表示一个输入范围， 第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给`copy`的目的序列至少要包含与输入序列一样多的元素
    * `copy`返回的是其目的位置迭代器递增后的值。即`ret`恰好指向拷贝到`a2`的尾元素之后的位置
  * `replace`替换算法函数：
    * 读入一个序列，并将其中所有等于给定值的元素都改为另一个值。
    * 接受4个参数：前两个hi迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。他将所有等于第一个值的元素替换为第二个值



### 10.2.3 重排容器元素的算法

* `sort`排序算法函数：
  * 调用`sort`会重排输入序列中的元素，是指有序，它是利用元素类型的<运算符来实现排序的
  * 接受三个参数：`sort(begin, end, cmp)`，前两个参数为表示范围的一对迭代器，第三个参数可以不写，不写时默认从小到大排序。如果向从大到小派新可以将`cmp`参数写为`greater<int>()`, `<>`中也可以写`double，long , float`等等
* `unique`算法：
  * 重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。
  * `unique`不会改变容器的大小，但其中的元素顺序被改变了。它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道他们的值时什么
* NOTE: 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素

***

#### 使用容器操作删除元素

删除一个空返回没有不良后果

***

## 10.3 定制操作

例如，`sort`算法默认我们使用元素类型的`<`运算符。但可能我们希望排序顺序与`<`锁定义的顺序不同，或是我们的序列可能保存的是未定义`<`运算符的类型（如`Sales_data`）。这两种情况下，都需要重载`sort`的默认行为。

### 10.3.1 向算法传递函数

例：作为一个例子，假定希望在调用`elimDups`(参见10.2.3节，第343页)后打印`vector`的内容。此外还假定希望单词按其长度排序，大小相同的再按字典序排列。为了按长度重排`vector`,我们将使用`sort`的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个 **谓词**（predicate）。

* 谓词：
  * 谓词是一个可调用的表达式，其返回结果

