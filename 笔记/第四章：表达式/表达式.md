# 基础

有一元运算符（作用一个对象）、二元运算符（作用域两个对象）、三元运算符

* 组合运算符和运算对象
 需了解运算符的优先级、结合律和求值顺序
* 运算对象转换
 通常不同数据类型的运算对象继续运算时，会被转化成同一种类型（一般被转化的更合乎情理）
* 重载运算符
 C++语言定义了运算符作用域内置类型和复合类型的运算对象时所执行的操作。当运算符作用与类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载**运算符**（overloaded operator）。IO库的`>>`和`<<`运算符以及`string`对象、`vector`对象和迭代器使用的运算符都是重载的运算符。
 我们使用重载运算符是，其包括运算对象的类型和返回值的类型，都是由该运算符定义的：但是运算对象的个数、运算符的优先级和结合律都是无法改变的
* 左值和右值
 

 ## 优先级与结合律

* 括号无视优先级与结合律


## 求值顺序

## 算术运算符

* 算数运算符（做结合律）
|   |   |   |
|---|---|---|
|   |   |   |
|   |   |   |
|   |   |   |

## 显式类型转换

形式：`cast-name<type>(expression)`
 type 式转换的额目标类型； expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`中的一种。`dynamic_cast`支持运行时类型识别，
 * `static_cast` 任何具有明确定义的类型转换，只要不包含底层const，都可以使用`static_cast`：`double slope = static_cast<double>(j)/i`
 * `const_cast`：只能改变运算对象的底层const;可去除常量对象的const属性。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，在适应const_cast执行写操作就会产生未定义的后果
 * `reinterpret_cast` 通常为运算对象的位模式提供较低层次上的重新解释，例如：
  ```cpp
  int *ip;
  char *pc = reinterpret_cast<char*>(ip);
  // 我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。例如：
  string str(pc); // 可能导致异常的运行时行为
  ```