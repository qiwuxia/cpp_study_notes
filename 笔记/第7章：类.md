# 类

类的基本思想是 **数据抽象**（data abstraction） 和 **封装**（encapsulation）。数据抽象是一种依赖于 **接口**（interface） 和 **实现**（implementation）分离的编程以及设计技术。类的接口包括用户所能执行的操作：类的实现则包括类的 **数据成员**、 **负责接口实现的函数体** 以及 **定义类所需的各种私有函数**

**封装**实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，即类的用户只能使用接口而无法访问实现部分

类要想实现数据抽象和封装，需要首先定义一个 **抽象数据类型**（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽象的思考类型做了什么，而无需了解类型的工作细节。 

## 定义抽象数据类型

### 设计Sale_data类

Sales_item类有一个名为isbn的 **成员函数**（number function）并且支持+、=、+=、<<和>>运算符。我们将学习如何定义这种类

我们将在14章学习如何自定义运算符。现在，我们纤维这些运算定义普通（命名的）函数形式。由于14章将要解释的原因，执行加法和IO函数不作为Sales_data的成员，相反的，我们将其定义成普通函数：执行复合赋值运算的函数时成员函数。Sales_data类无需专门定义赋值运算，其原因将在7.1.5节介绍

综上所述，Sales_data的接口应该包含一下操作：

* 一个isbn成员函数，用于返回对象的ISBN编号
* 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
* 一个名为add的函数，执行两个Sale_data对象的加法
* 一个read函数，将数据从istream读入Sales_data对象中
* 一个print函数，将Sales_data对象的值输出到ostream

#### 使用改进的Sales_data类

在考虑如何实现我们的类之前，首先来看看应该如何使用上面的接口函数。举个例子，我们使用这些函数编写1.6节（第21页）书店程序的另一个版本，其中不再使用Sales_item对象，而是使用Sales_data对象：

```cpp
Sales_data total;
if(read(cin, total))
{
    Sales_data trans; // 保存当前求和结果的变量
    while(read(cin, trans)) // 读入第一笔交易
    {
        if(total.isbn() == trans.isbn()) // 检查isbn
            total.combine(trans); // 更新变量当前的值
        else
        {
            print(cout,total)<<endl; //输出结果 ，print返回的时它的流参数的引用 print 的返回值作为<<运算符的左侧运算对象
            total = trans; //处理下一本书
        }
    }
        print(cout, total) << endl; // 输出最后一笔交易    
}
else //没有输入任何信息
{
    cerr << "No data?!" <<endl; // 通知用户
}
```

### 定义改进的Sales_data类

改进之后的类的数据成员将包括：bookNo, string类型， 表示ISBN编号; units_sold, unsigned类型，表示某本书的销量；以及revenue, double类型，表示真本书的总销售收入

如前所述，我们的类将包含两个成员函数：`combine`和`isbn`。此外，我们还将赋予Sales_data另一个成员函数用于返回售出书籍的平均价格，这个函数被命名为`avg_price`。因为`avg_price`的目的并非通用，所以它应该属于类的实现的一部分，而非接口的一部分。

**定义**和 **声明**成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，他们的定义和声明都在类的外部。

由此可知，改进的Sales_data类应该如下所示：

```cpp
struct Sales_data{
    // 新成员：关于Sales_data对象的操作
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    // 数据成员和2.6.1节相比没有改变
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
// Sales_data的非成员接口参数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::isteram&, Sales_data&);
```

* 定义在类内部的函数是隐式的inline（内联）函数

#### 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。对于Sales_data类来说，ibsn函数定义了类内，而combine和avg_price定义在了类外。

* isbn函数的参数列表为空返回值是一个string对象：

`std::string isbn() const { return bookNo;}`

和其他函数一样，成员函数体也是一个块。在此例中，块只要一条return语句，用于返回Sales_data对象的bookNo数据成员。关于isbn函数意见有意思的事情是：它是如何获得bookNo成员所依赖的对象内？

#### 引入this

让我i们再一次观察对isbn成员函数的调用：

`total.isbn()`

在这里，我们使用了点运算符来访问total对象的isbn成员，然后调用它。

后续将介绍一种例外的形式，当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员（例如boolNo）,则它隐式地指向调用该函数的对象的成员。在山后面所示的调用中，当isbn返回bookNo时，实际上它隐式的返回total.bookNo。

成员函数通过一个名为 **this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用

`total.isbn()`

则编译器负责把total的地址传递给isbn的隐式形参this，可以等价地认为编译器将该调用重写成了如下的形式：

```cpp
// 伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total)
```

其中，调用Sales_data的isbn成员时传入了total的地址。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookno时，它隐式地适应this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法。我们可以在成员函数体内部使用this,因此尽管没有必要，但我们还是能把isbn定义成如下的形式

`std::string isbn() const {return this->bookNo;}`

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址

#### 引入const成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this 的类型是`Sales_data *const`。尽管this是隐式的，但他仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就是的我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明称`const Sales_data *const`。毕竟， 在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高波函数的灵活性。

然而，this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作 **常量成员函数（const menmber function）**

可以把isbn的函数体想象成如下的形式：

```cpp
// 伪代码，说明隐式的this指针是如何使用的
// 下面的代码是非法的：因为我们不能显式地定义自己的this指针
// 谨记此处的this是一个指向常量的指针，因为isbn是一个常量成员
std::string Sales_data::isbn(const Sales_data * const this){return this->isbn} //非法
```

* 常量对象，以及常量对象的引用或指针都只能调用常量成员函数

#### 类作用域和成员函数

* 编译器首先编译成员的声明，然后才轮到成员函数体（如果有的话）
* 成员函数体可以随意使用类中的其他成员二无需在意这些成员出现的次序

#### 在类的外部定义成员函数

